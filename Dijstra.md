# Dijstra

1번 정점 부터 i번 정점 : Dis[i]

Dis[1] = 0 자기 자신의 거리는 0



1. 최단거리가 확정되지 않은 노드 중, Dis[i] 값이 가장 작은 노드 v 를 고른다.
2. 그 노드로 부터 이어진 간선들을 이용하여 Dis[w]들을 갱신한다.
3. 모든 노드가 확정되기 전까지, 1, 2 과정을 반복한다.





자료: {거리, 정점}

 https://www.youtube.com/watch?v=8icgu2zm9Dw 



# Union and Find : DisJoint Set

disjoint : 교집합이 없는 상태

1) 초기화 - 각각의 원소가 하나의 집합이 되게 함

2) Union : 합치기 - 두 원소 a, b 가 주어질 때, 이들이 속한 두 집합을 하나로 합침

3) Find : 찾기 - 어떤 원소 a가 주어질 때, 이 원소가 속한 집합을 반환

상호배타집합 할때 함



빠른 구현 - tree 활용

3 가지 좀 느린거 , 더 나은거 , 엄청 빠른거





# 위상 정렬(Topological Sort)

DAG(Directed Acyclic Graph)가 주어졌을 때, 정점들을 방향을 거스르지 않도록 일렬로 나열하는 것

모든 간선 "u -> v"에 대해서, 정점 u가 정점 v보다 앞에 와야함



관찰:

1. 제일 앞에 오는 정점은 Indegree가 0이여야 함

2. 위상 정렬을 한 후 Indegree가 0인 정점은 앞으로 옮겨도 정렬이 유지됨

   

### 알고리즘

1. Indegree가 0인 정점들을 큐에 추가한다.
2. 큐가 빌 때까지 다음을 반복한다.
   1. 큐에서 정점을 하나 뽑아 배치한다
   2. 해당 정점에서 뻗어나가는 간선들을 삭제한다.
   3. 이로 인해 Indegree가 0이 된 정점들을 큐에 추가한다.
3.  배치가 안된 정점이 남아있다면, 주어진 그래프에 사이클이 존재한다. (즉 DAG가 아님)